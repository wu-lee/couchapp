<!DOCTYPE html>
<html>
  <head>


<script type="text/javascript" src="/static/js/analytics.js"></script>
<link type="text/css" rel="stylesheet" href="/static/css/banner-styles.css"/>


    <title>Using backbone.js with couchapp - CouchApp.org</title>
    <link rel="stylesheet" href="/web/20140209091220cs_/http://couchapp.org/style/base-min.css" type="text/css">
    <link rel="stylesheet" href="/web/20140209091220cs_/http://couchapp.org/style/main.css" type="text/css">
  </head>
  <body>



    <div id="header">
      <div id="account"></div>      
      <h1><strong><a href="/web/20140209091220/http://couchapp.org/page/index">CouchApp.org</a>:</strong> <a href="/web/20140209091220/http://couchapp.org/page/backbone">Using backbone.js with couchapp</a></h1>
    </div>
    <div id="profile"></div>
    <div id="tools"></div>
    <div id="wiki"><div class="wiki"><p>Backbone.js is minimalist mvc framework for JavaScript, written by Jeremy ashkenas, the author of coffee script. Backbone is a good choice for creating larger couch apps, as an alternative to evently. A robust backbone-couchdb connector that supports realtime updates via the _changes feed is supported by Jan Monschke.</p>

<p>See this <a href="/web/20140209091220/http://janmonschke.posterous.com/backbone-couchdb-give-your-couchapp-some-back">introduction</a> to couch apps with backbone by Jan.</p>

<p>Extended version of Backbone.js couch connector (with fixing some issues, extending functionality) is available here:</p>

<p><a href="/web/20140209091220/https://github.com/andrzejsliwa/backbone-couch">https://github.com/andrzejsliwa/backbone-couch</a> </p>

<p>And example use case:</p>

<p><a href="/web/20140209091220/https://github.com/andrzejsliwa/couch-watch">https://github.com/andrzejsliwa/couch-watch</a></p></div></div>
    <div id="comments"></div>
    </body>
  <script src="/web/20140209091220js_/http://couchapp.org/script/myloader.js"></script>
  <script src="/web/20140209091220js_/http://couchapp.org/_utils/script/base64.js"></script>
  <script src="/web/20140209091220js_/http://couchapp.org/_utils/script/jquery.form.js"></script>
  <script type="text/javascript" charset="utf-8">
    var opts = {};
    if (document.location.pathname.indexOf("_design") == -1) {
      // we are in a vhost
      opts.db = "pages";
      opts.design = "pages";
    };
    opts.ddoc = {"lib":{"wiki":"var markdown = require(\"vendor/couchapp/lib/markdown\");\n\nfunction wikilinks(text) {\n  return text.replace(/\\[\\[(.*)\\]\\]/g,\"[$1]($1)\");\n};\n\nexports.encode = function(text) {\n  var linked = wikilinks(text);\n  return markdown.encode(linked);\n};"},"evently":{"profile":{"profileReady":{"all":"<div class=\"avatar\">\n  {{#gravatar_url}}<img src=\"{{gravatar_url}}\"/>{{/gravatar_url}}\n</div>\n<p class=\"menu\">\n  <a href=\"../page/index\">Home</a>\n  <a href=\"../pages/recent\">Changes</a>\n  <a href=\"../pages/comments\">Comments</a>\n</p>\n<div style=\"clear:left;\"></div>","mustache":"<div class=\"avatar\">\n  {{#gravatar_url}}<img src=\"{{gravatar_url}}\"/>{{/gravatar_url}}\n</div>\n<p class=\"menu\">\n  <a href=\"#/edit\">Edit</a>\n  <a href=\"#/history\">History</a>\n  <a href=\"#/upload\">Upload File</a>\n  <a href=\"../page/index\">Home</a>\n  <a href=\"../pages/recent\">Changes</a>\n  <a href=\"../pages/comments\">Comments</a>\n</p>\n<div style=\"clear:left;\"></div>"},"loggedOut":{"all":"<p class=\"menu\">\n  <a href=\"../page/index\">Home</a>\n  <a href=\"../pages/recent\">Changes</a>\n  <a href=\"../pages/comments\">Comments</a>\n</p>","mustache":"<p class=\"menu\">\n  <a href=\"../page/index\">Home</a>\n  <a href=\"../pages/recent\">Changes</a>\n  <a href=\"../pages/comments\">Comments</a>\n</p>"}},"wiki":{"edit":{"selectors":{"textarea[name=markdown]":{"keyup":"function() {\n  var form = $(this).parents(\"form\"), prev = $(\".preview\", form), app = $$(this).app,\n    f = form.serializeObject(),\n    wiki = app.require(\"lib/wiki\");\n  if ($$(prev).markdown != f.markdown) {\n    $$(prev).markdown = f.markdown;\n    $(prev).html(wiki.encode(f.markdown));\n    if (!$$(prev).timeout) {\n      $$(prev).timeout = setTimeout(function() {\n        $(\"#wiki\").trigger(\"_init\");\n        $$(prev).timeout = false;\n      }, 1100);\n    }\n  }\n}","_init":"function() {\n  var ta = $(this);\n  setTimeout(function() {\n    ta.trigger(\"keyup\");\n  },50);\n};"},"form":{"submit":"function() {\n  var form = $(this), app = $$(form).app,\n    f = form.serializeObject();\n  function saveDoc(doc) {\n    doc.title = f.title;\n    doc.markdown = f.markdown;\n    doc.edit_at = new Date();\n    doc.edit_by = $$(\"#profile\").profile || {};\n    doc.log = doc.log || [];\n    doc.log.push({\n      note : f.note,\n      prev_rev : f._rev,\n      rev_num : (parseInt(f._rev.split(\"-\")[0]) + 1) || 1,\n      edit_name : doc.edit_by.name,\n      edit_at : doc.edit_at\n    });\n    app.db.saveDoc(doc, {\n      success : function() {\n        window.location = window.location.pathname;\n      }\n    });    \n  };\n  if (f._rev) {\n    app.db.openDoc(f._id, {\n      success : function(doc) {\n        doc._rev = f._rev;\n        saveDoc(doc);\n      }\n    }); \n  } else {\n    // create a new page\n    saveDoc({\n      _id : f._id,\n      \"jquery.couch.attachPrevRev\" : true\n    });\n  }\n  return false;\n};"}},"partials":{"help":"<div class=\"markdown-help\">\n  <h3>Markdown basics:</h3>\n\n<pre>\n# Header 1\n## Header 2\n### Header 3\n#### Header 4\n##### Header 5 (looks like header 4 in most browsers)\n\nThis is a paragraph, which is text surrounded by whitespace. Paragraphs \ncan be on one line (or many), and can drone on for hours.  \n\n### Links\n\nHere is a Markdown link to [Apache CouchDB](/web/20140209091220/http://couchdb.apache.org), \nand a literal &lt;/web/20140209091220/http://link.com/&gt;.\n\nYou can link to other pages in the wiki like \nthis: [another page in the wiki](another-page)\n\n**note the wiki page id is just the thing in the parentheses**\n\nHere's a link to [the wiki home page](index).\n\nYou can also create links with CamelCase or with [[double-bracket-links]]\n\n### Emphasis\n\nNow some inline markup like _italics_, **bold**, and `code()`.\n\n### Images are easy\n\n![picture alt](/_utils/image/logo.png \"Title is optional\")     \n\n> Blockquotes are like quoted text in email replies\n>> And, they can be nested\n\nAnother paragraph, this one is longer: Lorem ipsum dolor sit amet, consectetur \nadipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna \naliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi \nut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in \nvoluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint \noccaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim \nid est laborum.\n\n* Bullet lists are easy too\n- Another one\n+ Another one\n\n### Horizontal rules\n\n* * * *\n\n****\n\n--------------------------\n\nAnd now some code:\n\n    // Code is just text indented a bit\n    which(is_easy) to_remember();\n    // it's indented by 4 spaces\n\nText with  \ntwo trailing spaces  \n(on the right)  \ncan be used  \nfor things like poems  \n\n_That's it, folks!_\n</pre>\n\n</div>"},"path":"/edit","async":"function(cb) {\n  var wiki = $(this), app = $$(wiki).app, docid = $$(wiki).docid;\n  app.db.openDoc(docid, {\n    success : function(doc) {\n      cb(doc);\n    },\n    error : function(code) {\n      if (code == 404) {\n        cb({_id : docid})\n      }\n    }\n  });\n};","data":"function(doc) {\n  return {\n    _id : doc._id,\n    _rev : doc._rev,\n    title : doc.title,\n    markdown : doc.markdown\n  };\n};","mustache":"<form>\n<div class=\"edit-form\">\n  <p>Editing: <a href=\"/page/{{_id}}\">/page/{{_id}}</a></p>\n  <p><label>Title: <input type=\"text\" name=\"title\" value=\"{{title}}\"></label></p>\n  <input type=\"hidden\" name=\"_rev\" value=\"{{_rev}}\">\n  <input type=\"hidden\" name=\"_id\" value=\"{{_id}}\">\n  <textarea name=\"markdown\" rows=\"30\" cols=\"70\">{{{markdown}}}</textarea>\n  <p><label>Optional description: <input size=\"60\" type=\"text\" name=\"note\" value=\"{{note}}\"></label> \n    <input type=\"submit\" value=\"Save Changes\">\n  </p>\n  {{>help}}\n</div>\n<div class=\"preview\"></div>\n<div class=\"clear\"></div>\n</form>"},"version":{"async":"function(cb, e, params) {\n  var wiki = $(this), app = $$(wiki).app, docid = $$(wiki).docid;\n  $.ajax({\n    type: \"GET\", url: app.db.uri + $.couch.encodeDocId(docid) + \"/rev-\" + params.num,\n    complete: function(req) {\n      var resp = $.httpData(req, \"json\");\n      if (req.status == 200) {\n        cb(resp);\n      } else {\n        alert(\"Could not open version: \" + resp.reason);\n      }\n    }\n  });\n\n};","data":"function(doc) {\n  var app = $$(this).app, wiki = app.require(\"lib/wiki\");\n  return {\n    body: wiki.encode(doc.markdown)\n  }\n\n};","mustache":"<p>{{{body}}}</p>","path":"/version/:num"},"_init":"function() {\n  var wiki = $(this), app = $$(wiki).app, m, pages = {}, keys = [];\n  $(\"a\",wiki).each(function() {\n    m = this.href.match(/.*\\/page\\/([^\\/]+)$/);\n    if (m && m[1]) {\n      pages[m[1]] = true;\n    }\n  });\n  // unique keys will be faster on big pages\n  for (m in pages) {\n    keys.push(m);\n  }\n  if (keys.length > 0) {\n    app.view(\"all-pages\", {\n      keys : keys,\n      success : function(resp) {\n        var i, p;\n        for (i=0; i < resp.rows.length; i++) {\n          p = resp.rows[i].key;\n          delete pages[p];\n        }\n        for (m in pages) {\n          $(\"a[href='\"+m+\"']\", wiki).addClass(\"missing\");\n        }\n      },\n      error : function() {}\n    });\n  }\n};"},"tools":{"upload":{"async":"function(cb) {\n  var wiki = $(this), app = $$(wiki).app, docid = $$(\"#wiki\").docid;\n  app.db.openDoc(docid, {\n    success : function(doc) {\n      cb(doc);\n    }\n  });\n};","selectors":{"form":{"submit":"function() {\n  var form = $(this), app = $$(form).app,\n    f = form.serializeObject();\n  \n  form.ajaxSubmit({\n    url: app.db.uri + $.couch.encodeDocId(f._id),\n    success: function(resp) {\n      window.location = window.location.pathname;\n    }\n  });\n  \n  return false;\n};"}},"data":"function(doc) {\n  return {\n    _id : doc._id,\n    _rev : doc._rev\n  };\n};","mustache":"<form>\n  <p>Upload a file to: <a href=\"/page/{{_id}}\">/page/{{_id}}</a></p>\n  <p><input type=\"file\" name=\"_attachments\"></p>\n  <input type=\"hidden\" name=\"_rev\" value=\"{{_rev}}\">\n  <input type=\"hidden\" name=\"_id\" value=\"{{_id}}\">\n  <p><input type=\"submit\" value=\"Upload File\"></p>\n</form>","path":"/upload"},"history":{"async":"function(cb) {\n  var wiki = $(\"#wiki\"), app = $$(wiki).app, docid = $$(wiki).docid;\n  app.db.openDoc(docid, {\n    success : function(doc) {\n      cb(doc);\n    }\n  });\n};","data":"function(doc) {\n  var topVer, name, stub, log, revNum, versions = [];\n  \n  function topVersionNum(doc) {\n    var topVer = 0, topLog = 0, name, revNum;\n    if (doc._attachments) {\n      for (name in doc._attachments) {\n        if (name.indexOf(\"rev\") == 0) {\n          revNum = parseInt(name.split('-')[1]);\n          if (revNum > topVer) {\n            topVer = revNum;\n          }\n        }\n      }\n    }\n    if (doc.log) {\n      for (var i=0; i < doc.log.length; i++) {\n        revNum = doc.log[i].rev_num;\n        if (revNum > topLog) {\n          topLog = revNum;\n        }\n      };\n    }\n    return Math.max(topLog, topVer);\n  };\n\n  topVer = topVersionNum(doc);\n  \n  for (var i=1; i <= topVer; i++) {\n    name = \"rev-\"+i;\n    stub = doc._attachments && doc._attachments[name];\n    for (var j=0; j < doc.log.length; j++) {\n      log = doc.log[j];\n      if (log.rev_num == i) break;\n      // backwards compatibility for jchris's docs\n      if ((parseInt(log.prev_rev || log.edit_rev) + 1) == i) break;\n      log = {};\n    };\n    versions.push({\n      available : !!stub,\n      missing : !stub,\n      rev : i == parseInt(doc._rev) ? \"current\" : i,\n      name : log.edit_name,\n      note : log.note\n    });\n  };\n\n  return {\n    _id : doc._id,\n    title : doc.title,\n    versions : versions.reverse()\n  };\n};","mustache":"<div class=\"versions\">\n  <h4>Versions of {{title}}</h4>\n  <ul>\n    {{#versions}}\n    <li>\n      {{#available}}\n        <a href=\"#/version/{{rev}}\">{{rev}} {{#name}} by {{name}}{{/name}}</a>\n      {{/available}}\n      {{#missing}}\n        {{rev}} {{#name}} by {{name}}{{/name}}\n      {{/missing}}\n      {{#note}}: {{note}}{{/note}}\n    </li>\n    {{/versions}}\n  </ul>\n</div>","path":"/history"}},"comments":{"_init":{"query":"function() {\n  var docid = $$(\"#wiki\").docid;\n  return {\n    view : \"recent-comments\",\n    endkey : [docid, {}],\n    startkey : [docid]\n  };\n};","after":"function() {\n  $(\".date\").prettyDate();\n};","data":"function(view) {\n  var docid = $$(\"#wiki\").docid,\n    linkup = $$(\"#wiki\").app.require(\"vendor/couchapp/lib/linkup\");\n  \n  return {\n    topic : docid,\n    title : $$(\"#wiki\").title,\n    comments : view.rows.map(function(r) {\n      var by = r.value.by || {};\n      return {\n        gravatar_url : by.gravatar_url,\n        by : by.nickname,\n        at : r.key[1],\n        comment : linkup.encode(r.value.comment) // move to view\n      }\n    })\n  }\n};","mustache":"<h3>Comments about {{title}}</h3>\n<ul>\n  {{#comments}}\n  <li>\n    <div class=\"avatar\">\n      {{#gravatar_url}}<img src=\"{{gravatar_url}}\"/>{{/gravatar_url}}\n      <div class=\"name\">\n        {{by}}\n      </div>\n    </div>\n    <p>{{{comment}}}</p>\n    <em><span class=\"date\">{{at}}</span></em>\n    <div class=\"clear\"></div>\n  </li>\n  {{/comments}}\n</ul>\n<form>\n  <label>Comment (w/ <a href=\"/web/20140209091220/http://github.com/couchapp/couchapp\" target=\"_new\">linkup</a>*)</label>\n  <br/>\n  <!-- <input type=\"text\" size=\"60\" name=\"comment\"> -->\n  <textarea name=\"comment\" rows=\"4\" cols=\"60\"></textarea>\n   <input type=\"hidden\" name=\"topic\" value=\"{{topic}}\">\n  <p><input type=\"submit\" value=\"Save Comment\"></p>\n</form>","selectors":{"form":{"submit":"function() {\n  var form = $(this), app = $$(form).app,\n    f = form.serializeObject();\n  f.type = \"comment\";\n  f.at = new Date();\n  f.by = $$(\"#profile\").profile;\n  app.db.saveDoc(f, {\n    success : function() {\n      $(\"#comments\").trigger(\"_init\");\n    }\n  })\n  return false;\n};"}}}}},"vendor":{"couchapp":{"evently":{"profile":{"profileReady":{"after":"function(e, p) {\n  $$(this).profile = p;\n};","data":"function(e, p) {\n  return p\n}","mustache":"<div class=\"avatar\">\n  {{#gravatar_url}}<img src=\"{{gravatar_url}}\"/>{{/gravatar_url}}\n  <div class=\"name\">\n    {{nickname}}\n  </div>\n</div>\n<p>Hello {{nickname}}!</p>\n<div style=\"clear:left;\"></div>"},"noProfile":{"data":"function(e, userCtx) {\n  return userCtx;\n}","mustache":"<form>\n  <p>Hello {{name}}, Please setup your user profile.</p>\n  <label for=\"nickname\">Nickname \n    <input type=\"text\" name=\"nickname\" value=\"\"></label>\n  <label for=\"email\">Email (<em>for <a href=\"/web/20140209091220/http://gravatar.com\">Gravatar</a></em>)\n    <input type=\"text\" name=\"email\" value=\"\"></label>\n  <label for=\"url\">URL \n    <input type=\"text\" name=\"url\" value=\"\"></label>\n  <input type=\"submit\" value=\"Go &rarr;\">\n  <input type=\"hidden\" name=\"userCtxName\" value=\"{{name}}\" id=\"userCtxName\">\n</form>","selectors":{"form":{"submit":"function() {\n  var md5 = $$(this).app.require(\"vendor/couchapp/lib/md5\");\n  \n  // TODO this can be cleaned up with docForm?\n  // it still needs the workflow to edit an existing profile\n  var name = $(\"input[name=userCtxName]\",this).val();\n  var newProfile = {\n    rand : Math.random().toString(), \n    nickname : $(\"input[name=nickname]\",this).val(),\n    email : $(\"input[name=email]\",this).val(),\n    url : $(\"input[name=url]\",this).val()\n  }, widget = $(this);\n\n  // setup gravatar_url\n  if (md5) {\n    newProfile.gravatar_url = '/web/20140209091220/http://www.gravatar.com/avatar/'+md5.hex(newProfile.email || newProfile.rand)+'.jpg?s=40&d=identicon';    \n  }\n\n  // store the user profile on the user account document\n  $.couch.userDb(function(db) {\n    var userDocId = \"org.couchdb.user:\"+name;\n    db.openDoc(userDocId, {\n      success : function(userDoc) {\n        userDoc[\"couch.app.profile\"] = newProfile;\n        db.saveDoc(userDoc, {\n          success : function() {\n            newProfile.name = userDoc.name;\n            $$(widget).profile = newProfile;\n            widget.trigger(\"profileReady\", [newProfile]);\n          }\n        });\n      }\n    });\n  });\n  return false;\n}"}}},"loggedIn":"function(e, r) {\n  var userCtx = r.userCtx;\n  var widget = $(this);\n  // load the profile from the user doc\n  var db = $.couch.db(r.info.authentication_db);\n  var userDocId = \"org.couchdb.user:\"+userCtx.name;\n  db.openDoc(userDocId, {\n    success : function(userDoc) {\n      var profile = userDoc[\"couch.app.profile\"];\n      if (profile) {\n        // we copy the name to the profile so it can be used later\n        // without publishing the entire userdoc (roles, pass, etc)\n        profile.name = userDoc.name;\n        $$(widget).profile = profile;\n        widget.trigger(\"profileReady\", [profile]);\n      } else {\n        widget.trigger(\"noProfile\", [userCtx]);\n      }\n    }\n  });\n}","loggedOut":{"after":"function() {\n  $$(this).profile = null;\n};","mustache":"<p>Please log in to see your profile.</p>"}},"docs":{"topic":{"edit":{"_init":{"selectors":{}}}}},"account":{"loggedIn":{"after":"function(e, r) {\n  $$(this).userCtx = r.userCtx;\n  $$(this).info = r.info;\n};","data":"function(e, r) {\n  return {\n    name : r.userCtx.name,\n    uri_name : encodeURIComponent(r.userCtx.name),\n    auth_db : encodeURIComponent(r.info.authentication_db)\n  };\n}","mustache":"<span>Welcome \n<a target=\"_new\" href=\"/_utils/document.html?{{auth_db}}/org.couchdb.user%3A{{uri_name}}\">{{name}}</a>! \n<a href=\"#logout\">Logout?</a>\n</span>","selectors":{"a[href=#logout]":{"click":["doLogout"]}}},"signupForm":{"after":"function() {\n  $(\"input[name=name]\", this).focus();\n}","mustache":"<form>\n  <label for=\"name\">Name</label> <input type=\"text\" name=\"name\" value=\"\">\n  <label for=\"password\">Password</label> <input type=\"password\" name=\"password\" value=\"\">\n  <input type=\"submit\" value=\"Signup\">\n  <a href=\"#login\">or Login</a>\n</form>","selectors":{"a[href=#login]":{"click":["loginForm"]},"form":{"submit":"function(e) {\n  var name = $('input[name=name]', this).val(),\n    pass = $('input[name=password]', this).val();              \n  $(this).trigger('doSignup', [name, pass]);\n  return false;\n}"}}},"_init":"function() {\n  var elem = $(this);\n  $$(this).userCtx = null;\n  $.couch.session({\n    success : function(r) {\n      var userCtx = r.userCtx;\n      if (userCtx.name) {\n        elem.trigger(\"loggedIn\", [r]);\n      } else if (userCtx.roles.indexOf(\"_admin\") != -1) {\n        elem.trigger(\"adminParty\");\n      } else {\n        elem.trigger(\"loggedOut\");\n      };\n    }\n  });\n}","doLogout":"function() {\n  var elem = $(this);\n  $.couch.logout({\n    success : function() {\n      elem.trigger(\"_init\");\n    }\n  });\n}","doSignup":"function(e, name, pass) {\n  var elem = $(this);\n  $.couch.signup({\n    name : name\n  }, pass, {\n    success : function() {\n      elem.trigger(\"doLogin\", [name, pass]);\n    }\n  });\n}","adminParty":{"mustache":"<p><strong>Admin party, everyone is admin!</strong> Fix this in <a href=\"/_utils/index.html\">Futon</a> before proceeding.</p>"},"loggedOut":{"mustache":"<a href=\"#signup\">Signup</a> or <a href=\"#login\">Login</a>","selectors":{"a[href=#login]":{"click":["loginForm"]},"a[href=#signup]":{"click":["signupForm"]}}},"loginForm":{"after":"function() {\n  $(\"input[name=name]\", this).focus();\n}","mustache":"<form>\n  <label for=\"name\">Name</label> <input type=\"text\" name=\"name\" value=\"\">\n  <label for=\"password\">Password</label> <input type=\"password\" name=\"password\" value=\"\">\n  <input type=\"submit\" value=\"Login\">\n  <a href=\"#signup\">or Signup</a>\n</form>","selectors":{"form":{"submit":"function(e) {\n  var name = $('input[name=name]', this).val(),\n    pass = $('input[name=password]', this).val();              \n  $(this).trigger('doLogin', [name, pass]);\n  return false;\n}"},"a[href=#signup]":{"click":["signupForm"]}}},"doLogin":"function(e, name, pass) {\n  var elem = $(this);\n  $.couch.login({\n    name : name,\n    password : pass,\n    success : function(r) {\n      elem.trigger(\"_init\")\n    }\n  });      \n}"},"README":"## Starting the Document this code challenge\n\nI need help on this code. I only have so many hours in the day. Please be liberal about patching and hacking (and sharing code!) so we can all benefit. \n\nDocs patches are deeply appreciated. For now you can just stick Markdown files in the Docs directory.\n\n# Evently\n\nThese are some vendor Evently widgets that are running on the CouchApp system.\n\n## Account\n  This is how you signup, login and logout without worry about the code.\n  Todo, we could have this work against remote APIs like that Facebook stuff or whatever.\n\n\n## Profile\n  Use this to load the local users profile for the logged in user. Useful if you're going to be posting new messages. Most applications end up customizing `profile.profileReady` to render the primary data-entry form. This gets you benefits like refreshing on login / logout, etc, automatically.\n\n\n## Docs\n  This needs to be moved to it's own app.\n  I have this vision of a docs app designed for offline editing, that involves each Markdown paragraph being it's own document, with automatic use of Bespin for code samples. Any help on this would be thanked much."},"lib":{"linkup":"// this code makes /web/20140209091220/http://example.com into a link, \n// and also handles @name and #hashtag\n\n// todo add [[wiki_links]]\n\nvar mustache = require(\"vendor/couchapp/lib/mustache\");\nexports.encode = function(body, person_prefix, tag_prefix) {\n  body = mustache.escape(body);\n  person_prefix = person_prefix || \"/web/20140209091220/http://twitter.com/\";\n  tag_prefix = tag_prefix || \"/web/20140209091220/http://delicious.com/tag/\";\n  return body.replace(/((ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?)/gi,function(a) {\n    return '<a target=\"_blank\" href=\"'+a+'\">'+a+'</a>';\n  }).replace(/\\@([\\w\\-]+)/g,function(user,name) {\n    return '<a href=\"'+person_prefix+encodeURIComponent(name.toLowerCase())+'\">'+user+'</a>';\n  }).replace(/\\#([\\w\\-\\.]+)/g,function(word,tag) {\n    return '<a href=\"'+tag_prefix+encodeURIComponent(tag.toLowerCase())+'\">'+word+'</a>';\n  });\n};","markdown":"//\n// showdown.js -- A javascript port of Markdown.\n//\n// Copyright (c) 2007 John Fraser.\n//\n// Original Markdown Copyright (c) 2004-2005 John Gruber\n//   </web/20140209091220/http://daringfireball.net/projects/markdown/>\n//\n// Redistributable under a BSD-style open source license.\n// See license.txt for more information.\n//\n// The full source distribution is at:\n//\n//\t\t\t\tA A L\n//\t\t\t\tT C A\n//\t\t\t\tT K B\n//\n//   </web/20140209091220/http://www.attacklab.net/>\n//\n\n//\n// Wherever possible, Showdown is a straight, line-by-line port\n// of the Perl version of Markdown.\n//\n// This is not a normal parser design; it's basically just a\n// series of string substitutions.  It's hard to read and\n// maintain this way,  but keeping Showdown close to the original\n// design makes it easier to port new features.\n//\n// More importantly, Showdown behaves like markdown.pl in most\n// edge cases.  So web applications can do client-side preview\n// in Javascript, and then build identical HTML on the server.\n//\n// This port needs the new RegExp functionality of ECMA 262,\n// 3rd Edition (i.e. Javascript 1.5).  Most modern web browsers\n// should do fine.  Even with the new regular expression features,\n// We do a lot of work to emulate Perl's regex functionality.\n// The tricky changes in this file mostly have the \"attacklab:\"\n// label.  Major or self-explanatory changes don't.\n//\n// Smart diff tools like Araxis Merge will be able to match up\n// this file with markdown.pl in a useful way.  A little tweaking\n// helps: in a copy of markdown.pl, replace \"#\" with \"//\" and\n// replace \"$text\" with \"text\".  Be sure to ignore whitespace\n// and line endings.\n//\n\n\n//\n// Showdown usage:\n//\n//   var text = \"Markdown *rocks*.\";\n//\n//   var markdown = require(\"markdown\");\n//   var html = markdown.encode(text);\n//\n//   print(html);\n//\n// Note: move the sample code to the bottom of this\n// file before uncommenting it.\n//\n\n\n//\n// Globals:\n//\n\n// Global hashes, used by various utility routines\nvar g_urls;\nvar g_titles;\nvar g_html_blocks;\n\n// Used to track when we're inside an ordered or unordered list\n// (see _ProcessListItems() for details):\nvar g_list_level = 0;\n\n\nexports.makeHtml = function(text) {\n//\n// Main function. The order in which other subs are called here is\n// essential. Link and image substitutions need to happen before\n// _EscapeSpecialCharsWithinTagAttributes(), so that any *'s or _'s in the <a>\n// and <img> tags get encoded.\n//\n\n\t// Clear the global hashes. If we don't clear these, you get conflicts\n\t// from other articles when generating a page which contains more than\n\t// one article (e.g. an index page that shows the N most recent\n\t// articles):\n\tg_urls = new Array();\n\tg_titles = new Array();\n\tg_html_blocks = new Array();\n\n\t// attacklab: Replace ~ with ~T\n\t// This lets us use tilde as an escape char to avoid md5 hashes\n\t// The choice of character is arbitray; anything that isn't\n    // magic in Markdown will work.\n\ttext = text.replace(/~/g,\"~T\");\n\n\t// attacklab: Replace $ with ~D\n\t// RegExp interprets $ as a special character\n\t// when it's in a replacement string\n\ttext = text.replace(/\\$/g,\"~D\");\n\n\t// Standardize line endings\n\ttext = text.replace(/\\r\\n/g,\"\\n\"); // DOS to Unix\n\ttext = text.replace(/\\r/g,\"\\n\"); // Mac to Unix\n\n\t// Make sure text begins and ends with a couple of newlines:\n\ttext = \"\\n\\n\" + text + \"\\n\\n\";\n\n\t// Convert all tabs to spaces.\n\ttext = _Detab(text);\n\n\t// Strip any lines consisting only of spaces and tabs.\n\t// This makes subsequent regexen easier to write, because we can\n\t// match consecutive blank lines with /\\n+/ instead of something\n\t// contorted like /[ \\t]*\\n+/ .\n\ttext = text.replace(/^[ \\t]+$/mg,\"\");\n\n\t// Turn block-level HTML blocks into hash entries\n\ttext = _HashHTMLBlocks(text);\n\n\t// Strip link definitions, store in hashes.\n\ttext = _StripLinkDefinitions(text);\n\n\ttext = _RunBlockGamut(text);\n\n\ttext = _UnescapeSpecialChars(text);\n\n\t// attacklab: Restore dollar signs\n\ttext = text.replace(/~D/g,\"$$\");\n\n\t// attacklab: Restore tildes\n\ttext = text.replace(/~T/g,\"~\");\n\treturn text;\n}\n\n\nvar _StripLinkDefinitions = function(text) {\n//\n// Strips link definitions from text, stores the URLs and titles in\n// hash references.\n//\n\n\t// Link defs are in the form: ^[id]: url \"optional title\"\n\n\t/*\n\t\tvar text = text.replace(/\n\t\t\t\t^[ ]{0,3}\\[(.+)\\]:  // id = $1  attacklab: g_tab_width - 1\n\t\t\t\t  [ \\t]*\n\t\t\t\t  \\n?\t\t\t\t// maybe *one* newline\n\t\t\t\t  [ \\t]*\n\t\t\t\t<?(\\S+?)>?\t\t\t// url = $2\n\t\t\t\t  [ \\t]*\n\t\t\t\t  \\n?\t\t\t\t// maybe one newline\n\t\t\t\t  [ \\t]*\n\t\t\t\t(?:\n\t\t\t\t  (\\n*)\t\t\t\t// any lines skipped = $3 attacklab: lookbehind removed\n\t\t\t\t  [\"(]\n\t\t\t\t  (.+?)\t\t\t\t// title = $4\n\t\t\t\t  [\")]\n\t\t\t\t  [ \\t]*\n\t\t\t\t)?\t\t\t\t\t// title is optional\n\t\t\t\t(?:\\n+|$)\n\t\t\t  /gm,\n\t\t\t  function(){...});\n\t*/\n\tvar text = text.replace(/^[ ]{0,3}\\[(.+)\\]:[ \\t]*\\n?[ \\t]*<?(\\S+?)>?[ \\t]*\\n?[ \\t]*(?:(\\n*)[\"(](.+?)[\")][ \\t]*)?(?:\\n+|\\Z)/gm,\n\t\tfunction (wholeMatch,m1,m2,m3,m4) {\n\t\t\tm1 = m1.toLowerCase();\n\t\t\tg_urls[m1] = _EncodeAmpsAndAngles(m2);  // Link IDs are case-insensitive\n\t\t\tif (m3) {\n\t\t\t\t// Oops, found blank lines, so it's not a title.\n\t\t\t\t// Put back the parenthetical statement we stole.\n\t\t\t\treturn m3+m4;\n\t\t\t} else if (m4) {\n\t\t\t\tg_titles[m1] = m4.replace(/\"/g,\"&quot;\");\n\t\t\t}\n\t\t\t\n\t\t\t// Completely remove the definition from the text\n\t\t\treturn \"\";\n\t\t}\n\t);\n\n\treturn text;\n}\n\n\nvar _HashHTMLBlocks = function(text) {\n\t// attacklab: Double up blank lines to reduce lookaround\n\ttext = text.replace(/\\n/g,\"\\n\\n\");\n\n\t// Hashify HTML blocks:\n\t// We only want to do this for block-level HTML tags, such as headers,\n\t// lists, and tables. That's because we still want to wrap <p>s around\n\t// \"paragraphs\" that are wrapped in non-block-level tags, such as anchors,\n\t// phrase emphasis, and spans. The list of tags we're looking for is\n\t// hard-coded:\n\tvar block_tags_a = \"p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del\"\n\tvar block_tags_b = \"p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math\"\n\n\t// First, look for nested blocks, e.g.:\n\t//   <div>\n\t//     <div>\n\t//     tags for inner block must be indented.\n\t//     </div>\n\t//   </div>\n\t//\n\t// The outermost tags must start at the left margin for this to match, and\n\t// the inner nested divs must be indented.\n\t// We need to do this before the next, more liberal match, because the next\n\t// match will start at the first `<div>` and stop at the first `</div>`.\n\n\t// attacklab: This regex can be expensive when it fails.\n\t/*\n\t\tvar text = text.replace(/\n\t\t(\t\t\t\t\t\t// save in $1\n\t\t\t^\t\t\t\t\t// start of line  (with /m)\n\t\t\t<($block_tags_a)\t// start tag = $2\n\t\t\t\\b\t\t\t\t\t// word break\n\t\t\t\t\t\t\t\t// attacklab: hack around khtml/pcre bug...\n\t\t\t[^\\r]*?\\n\t\t\t// any number of lines, minimally matching\n\t\t\t</\\2>\t\t\t\t// the matching end tag\n\t\t\t[ \\t]*\t\t\t\t// trailing spaces/tabs\n\t\t\t(?=\\n+)\t\t\t\t// followed by a newline\n\t\t)\t\t\t\t\t\t// attacklab: there are sentinel newlines at end of document\n\t\t/gm,function(){...}};\n\t*/\n\ttext = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\\b[^\\r]*?\\n<\\/\\2>[ \\t]*(?=\\n+))/gm,hashElement);\n\n\t//\n\t// Now match more liberally, simply from `\\n<tag>` to `</tag>\\n`\n\t//\n\n\t/*\n\t\tvar text = text.replace(/\n\t\t(\t\t\t\t\t\t// save in $1\n\t\t\t^\t\t\t\t\t// start of line  (with /m)\n\t\t\t<($block_tags_b)\t// start tag = $2\n\t\t\t\\b\t\t\t\t\t// word break\n\t\t\t\t\t\t\t\t// attacklab: hack around khtml/pcre bug...\n\t\t\t[^\\r]*?\t\t\t\t// any number of lines, minimally matching\n\t\t\t.*</\\2>\t\t\t\t// the matching end tag\n\t\t\t[ \\t]*\t\t\t\t// trailing spaces/tabs\n\t\t\t(?=\\n+)\t\t\t\t// followed by a newline\n\t\t)\t\t\t\t\t\t// attacklab: there are sentinel newlines at end of document\n\t\t/gm,function(){...}};\n\t*/\n\ttext = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math)\\b[^\\r]*?.*<\\/\\2>[ \\t]*(?=\\n+)\\n)/gm,hashElement);\n\n\t// Special case just for <hr />. It was easier to make a special case than\n\t// to make the other regex more complicated.  \n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t// save in $1\n\t\t\t\\n\\n\t\t\t\t// Starting after a blank line\n\t\t\t[ ]{0,3}\n\t\t\t(<(hr)\t\t\t\t// start tag = $2\n\t\t\t\\b\t\t\t\t\t// word break\n\t\t\t([^<>])*?\t\t\t// \n\t\t\t\\/?>)\t\t\t\t// the matching end tag\n\t\t\t[ \\t]*\n\t\t\t(?=\\n{2,})\t\t\t// followed by a blank line\n\t\t)\n\t\t/g,hashElement);\n\t*/\n\ttext = text.replace(/(\\n[ ]{0,3}(<(hr)\\b([^<>])*?\\/?>)[ \\t]*(?=\\n{2,}))/g,hashElement);\n\n\t// Special case for standalone HTML comments:\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t// save in $1\n\t\t\t\\n\\n\t\t\t\t// Starting after a blank line\n\t\t\t[ ]{0,3}\t\t\t// attacklab: g_tab_width - 1\n\t\t\t<!\n\t\t\t(--[^\\r]*?--\\s*)+\n\t\t\t>\n\t\t\t[ \\t]*\n\t\t\t(?=\\n{2,})\t\t\t// followed by a blank line\n\t\t)\n\t\t/g,hashElement);\n\t*/\n\ttext = text.replace(/(\\n\\n[ ]{0,3}<!(--[^\\r]*?--\\s*)+>[ \\t]*(?=\\n{2,}))/g,hashElement);\n\n\t// PHP and ASP-style processor instructions (<?...?> and <%...%>)\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(?:\n\t\t\t\\n\\n\t\t\t\t// Starting after a blank line\n\t\t)\n\t\t(\t\t\t\t\t\t// save in $1\n\t\t\t[ ]{0,3}\t\t\t// attacklab: g_tab_width - 1\n\t\t\t(?:\n\t\t\t\t<([?%])\t\t\t// $2\n\t\t\t\t[^\\r]*?\n\t\t\t\t\\2>\n\t\t\t)\n\t\t\t[ \\t]*\n\t\t\t(?=\\n{2,})\t\t\t// followed by a blank line\n\t\t)\n\t\t/g,hashElement);\n\t*/\n\ttext = text.replace(/(?:\\n\\n)([ ]{0,3}(?:<([?%])[^\\r]*?\\2>)[ \\t]*(?=\\n{2,}))/g,hashElement);\n\n\t// attacklab: Undo double lines (see comment at top of this function)\n\ttext = text.replace(/\\n\\n/g,\"\\n\");\n\treturn text;\n}\n\nvar hashElement = function(wholeMatch,m1) {\n\tvar blockText = m1;\n\n\t// Undo double lines\n\tblockText = blockText.replace(/\\n\\n/g,\"\\n\");\n\tblockText = blockText.replace(/^\\n/,\"\");\n\t\n\t// strip trailing blank lines\n\tblockText = blockText.replace(/\\n+$/g,\"\");\n\t\n\t// Replace the element text with a marker (\"~KxK\" where x is its key)\n\tblockText = \"\\n\\n~K\" + (g_html_blocks.push(blockText)-1) + \"K\\n\\n\";\n\t\n\treturn blockText;\n};\n\nvar _RunBlockGamut = function(text) {\n//\n// These are all the transformations that form block-level\n// tags like paragraphs, headers, and list items.\n//\n\ttext = _DoHeaders(text);\n\n\t// Do Horizontal Rules:\n\tvar key = hashBlock(\"<hr />\");\n\ttext = text.replace(/^[ ]{0,2}([ ]?\\*[ ]?){3,}[ \\t]*$/gm,key);\n\ttext = text.replace(/^[ ]{0,2}([ ]?\\-[ ]?){3,}[ \\t]*$/gm,key);\n\ttext = text.replace(/^[ ]{0,2}([ ]?\\_[ ]?){3,}[ \\t]*$/gm,key);\n\n\ttext = _DoLists(text);\n\ttext = _DoCodeBlocks(text);\n\ttext = _DoBlockQuotes(text);\n\n\t// We already ran _HashHTMLBlocks() before, in Markdown(), but that\n\t// was to escape raw HTML in the original Markdown source. This time,\n\t// we're escaping the markup we've just created, so that we don't wrap\n\t// <p> tags around block-level tags.\n\ttext = _HashHTMLBlocks(text);\n\ttext = _FormParagraphs(text);\n\n\treturn text;\n}\n\n\nvar _RunSpanGamut = function(text) {\n//\n// These are all the transformations that occur *within* block-level\n// tags like paragraphs, headers, and list items.\n//\n\n\ttext = _DoCodeSpans(text);\n\ttext = _EscapeSpecialCharsWithinTagAttributes(text);\n\ttext = _EncodeBackslashEscapes(text);\n\n\t// Process anchor and image tags. Images must come first,\n\t// because ![foo][f] looks like an anchor.\n\ttext = _DoImages(text);\n\ttext = _DoAnchors(text);\n\n\t// Make links out of things like `</web/20140209091220/http://example.com/>`\n\t// Must come after _DoAnchors(), because you can use < and >\n\t// delimiters in inline links like [this](<url>).\n\ttext = _DoAutoLinks(text);\n\ttext = _EncodeAmpsAndAngles(text);\n\ttext = _DoItalicsAndBold(text);\n\n\t// Do hard breaks:\n\ttext = text.replace(/  +\\n/g,\" <br />\\n\");\n\n\treturn text;\n}\n\nvar _EscapeSpecialCharsWithinTagAttributes = function(text) {\n//\n// Within tags -- meaning between < and > -- encode [\\ ` * _] so they\n// don't conflict with their use in Markdown for code, italics and strong.\n//\n\n\t// Build a regex to find HTML tags and comments.  See Friedl's \n\t// \"Mastering Regular Expressions\", 2nd Ed., pp. 200-201.\n\tvar regex = /(<[a-z\\/!$](\"[^\"]*\"|'[^']*'|[^'\">])*>|<!(--.*?--\\s*)+>)/gi;\n\n\ttext = text.replace(regex, function(wholeMatch) {\n\t\tvar tag = wholeMatch.replace(/(.)<\\/?code>(?=.)/g,\"$1`\");\n\t\ttag = escapeCharacters(tag,\"\\\\`*_\");\n\t\treturn tag;\n\t});\n\n\treturn text;\n}\n\nvar _DoAnchors = function(text) {\n//\n// Turn Markdown link shortcuts into XHTML <a> tags.\n//\n\t//\n\t// First, handle reference-style links: [link text] [id]\n\t//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t\t// wrap whole match in $1\n\t\t\t\\[\n\t\t\t(\n\t\t\t\t(?:\n\t\t\t\t\t\\[[^\\]]*\\]\t\t// allow brackets nested one level\n\t\t\t\t\t|\n\t\t\t\t\t[^\\[]\t\t\t// or anything else\n\t\t\t\t)*\n\t\t\t)\n\t\t\t\\]\n\n\t\t\t[ ]?\t\t\t\t\t// one optional space\n\t\t\t(?:\\n[ ]*)?\t\t\t\t// one optional newline followed by spaces\n\n\t\t\t\\[\n\t\t\t(.*?)\t\t\t\t\t// id = $3\n\t\t\t\\]\n\t\t)()()()()\t\t\t\t\t// pad remaining backreferences\n\t\t/g,_DoAnchors_callback);\n\t*/\n\ttext = text.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g,writeAnchorTag);\n\n\t//\n\t// Next, inline-style links: [link text](url \"optional title\")\n\t//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t\t(\t\t\t\t\t\t// wrap whole match in $1\n\t\t\t\t\\[\n\t\t\t\t(\n\t\t\t\t\t(?:\n\t\t\t\t\t\t\\[[^\\]]*\\]\t// allow brackets nested one level\n\t\t\t\t\t|\n\t\t\t\t\t[^\\[\\]]\t\t\t// or anything else\n\t\t\t\t)\n\t\t\t)\n\t\t\t\\]\n\t\t\t\\(\t\t\t\t\t\t// literal paren\n\t\t\t[ \\t]*\n\t\t\t()\t\t\t\t\t\t// no id, so leave $3 empty\n\t\t\t<?(.*?)>?\t\t\t\t// href = $4\n\t\t\t[ \\t]*\n\t\t\t(\t\t\t\t\t\t// $5\n\t\t\t\t(['\"])\t\t\t\t// quote char = $6\n\t\t\t\t(.*?)\t\t\t\t// Title = $7\n\t\t\t\t\\6\t\t\t\t\t// matching quote\n\t\t\t\t[ \\t]*\t\t\t\t// ignore any spaces/tabs between closing quote and )\n\t\t\t)?\t\t\t\t\t\t// title is optional\n\t\t\t\\)\n\t\t)\n\t\t/g,writeAnchorTag);\n\t*/\n\ttext = text.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]\\([ \\t]*()<?(.*?)>?[ \\t]*((['\"])(.*?)\\6[ \\t]*)?\\))/g,writeAnchorTag);\n\n\t//\n\t// Last, handle reference-style shortcuts: [link text]\n\t// These must come last in case you've also got [link test][1]\n\t// or [link test](/foo)\n\t//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t \t\t\t\t\t// wrap whole match in $1\n\t\t\t\\[\n\t\t\t([^\\[\\]]+)\t\t\t\t// link text = $2; can't contain '[' or ']'\n\t\t\t\\]\n\t\t)()()()()()\t\t\t\t\t// pad rest of backreferences\n\t\t/g, writeAnchorTag);\n\t*/\n\ttext = text.replace(/(\\[([^\\[\\]]+)\\])()()()()()/g, writeAnchorTag);\n\n\treturn text;\n}\n\nvar writeAnchorTag = function(wholeMatch,m1,m2,m3,m4,m5,m6,m7) {\n\tif (m7 == undefined) m7 = \"\";\n\tvar whole_match = m1;\n\tvar link_text   = m2;\n\tvar link_id\t = m3.toLowerCase();\n\tvar url\t\t= m4;\n\tvar title\t= m7;\n\t\n\tif (url == \"\") {\n\t\tif (link_id == \"\") {\n\t\t\t// lower-case and turn embedded newlines into spaces\n\t\t\tlink_id = link_text.toLowerCase().replace(/ ?\\n/g,\" \");\n\t\t}\n\t\turl = \"#\"+link_id;\n\t\t\n\t\tif (g_urls[link_id] != undefined) {\n\t\t\turl = g_urls[link_id];\n\t\t\tif (g_titles[link_id] != undefined) {\n\t\t\t\ttitle = g_titles[link_id];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (whole_match.search(/\\(\\s*\\)$/m)>-1) {\n\t\t\t\t// Special case for explicit empty url\n\t\t\t\turl = \"\";\n\t\t\t} else {\n\t\t\t\treturn whole_match;\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\turl = escapeCharacters(url,\"*_\");\n\tvar result = \"<a href=\\\"\" + url + \"\\\"\";\n\t\n\tif (title != \"\") {\n\t\ttitle = title.replace(/\"/g,\"&quot;\");\n\t\ttitle = escapeCharacters(title,\"*_\");\n\t\tresult +=  \" title=\\\"\" + title + \"\\\"\";\n\t}\n\t\n\tresult += \">\" + link_text + \"</a>\";\n\t\n\treturn result;\n}\n\n\nvar _DoImages = function(text) {\n//\n// Turn Markdown image shortcuts into <img> tags.\n//\n\n\t//\n\t// First, handle reference-style labeled images: ![alt text][id]\n\t//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t// wrap whole match in $1\n\t\t\t!\\[\n\t\t\t(.*?)\t\t\t\t// alt text = $2\n\t\t\t\\]\n\n\t\t\t[ ]?\t\t\t\t// one optional space\n\t\t\t(?:\\n[ ]*)?\t\t\t// one optional newline followed by spaces\n\n\t\t\t\\[\n\t\t\t(.*?)\t\t\t\t// id = $3\n\t\t\t\\]\n\t\t)()()()()\t\t\t\t// pad rest of backreferences\n\t\t/g,writeImageTag);\n\t*/\n\ttext = text.replace(/(!\\[(.*?)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g,writeImageTag);\n\n\t//\n\t// Next, handle inline images:  ![alt text](url \"optional title\")\n\t// Don't forget: encode * and _\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t// wrap whole match in $1\n\t\t\t!\\[\n\t\t\t(.*?)\t\t\t\t// alt text = $2\n\t\t\t\\]\n\t\t\t\\s?\t\t\t\t\t// One optional whitespace character\n\t\t\t\\(\t\t\t\t\t// literal paren\n\t\t\t[ \\t]*\n\t\t\t()\t\t\t\t\t// no id, so leave $3 empty\n\t\t\t<?(\\S+?)>?\t\t\t// src url = $4\n\t\t\t[ \\t]*\n\t\t\t(\t\t\t\t\t// $5\n\t\t\t\t(['\"])\t\t\t// quote char = $6\n\t\t\t\t(.*?)\t\t\t// title = $7\n\t\t\t\t\\6\t\t\t\t// matching quote\n\t\t\t\t[ \\t]*\n\t\t\t)?\t\t\t\t\t// title is optional\n\t\t\\)\n\t\t)\n\t\t/g,writeImageTag);\n\t*/\n\ttext = text.replace(/(!\\[(.*?)\\]\\s?\\([ \\t]*()<?(\\S+?)>?[ \\t]*((['\"])(.*?)\\6[ \\t]*)?\\))/g,writeImageTag);\n\n\treturn text;\n}\n\nvar writeImageTag = function(wholeMatch,m1,m2,m3,m4,m5,m6,m7) {\n\tvar whole_match = m1;\n\tvar alt_text   = m2;\n\tvar link_id\t = m3.toLowerCase();\n\tvar url\t\t= m4;\n\tvar title\t= m7;\n\n\tif (!title) title = \"\";\n\t\n\tif (url == \"\") {\n\t\tif (link_id == \"\") {\n\t\t\t// lower-case and turn embedded newlines into spaces\n\t\t\tlink_id = alt_text.toLowerCase().replace(/ ?\\n/g,\" \");\n\t\t}\n\t\turl = \"#\"+link_id;\n\t\t\n\t\tif (g_urls[link_id] != undefined) {\n\t\t\turl = g_urls[link_id];\n\t\t\tif (g_titles[link_id] != undefined) {\n\t\t\t\ttitle = g_titles[link_id];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn whole_match;\n\t\t}\n\t}\t\n\t\n\talt_text = alt_text.replace(/\"/g,\"&quot;\");\n\turl = escapeCharacters(url,\"*_\");\n\tvar result = \"<img src=\\\"\" + url + \"\\\" alt=\\\"\" + alt_text + \"\\\"\";\n\n\t// attacklab: Markdown.pl adds empty title attributes to images.\n\t// Replicate this bug.\n\n\t//if (title != \"\") {\n\t\ttitle = title.replace(/\"/g,\"&quot;\");\n\t\ttitle = escapeCharacters(title,\"*_\");\n\t\tresult +=  \" title=\\\"\" + title + \"\\\"\";\n\t//}\n\t\n\tresult += \" />\";\n\t\n\treturn result;\n}\n\n\nvar _DoHeaders = function(text) {\n\n\t// Setext-style headers:\n\t//\tHeader 1\n\t//\t========\n\t//  \n\t//\tHeader 2\n\t//\t--------\n\t//\n\ttext = text.replace(/^(.+)[ \\t]*\\n=+[ \\t]*\\n+/gm,\n\t\tfunction(wholeMatch,m1){return hashBlock(\"<h1>\" + _RunSpanGamut(m1) + \"</h1>\");});\n\n\ttext = text.replace(/^(.+)[ \\t]*\\n-+[ \\t]*\\n+/gm,\n\t\tfunction(matchFound,m1){return hashBlock(\"<h2>\" + _RunSpanGamut(m1) + \"</h2>\");});\n\n\t// atx-style headers:\n\t//  # Header 1\n\t//  ## Header 2\n\t//  ## Header 2 with closing hashes ##\n\t//  ...\n\t//  ###### Header 6\n\t//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t\t^(\\#{1,6})\t\t\t\t// $1 = string of #'s\n\t\t\t[ \\t]*\n\t\t\t(.+?)\t\t\t\t\t// $2 = Header text\n\t\t\t[ \\t]*\n\t\t\t\\#*\t\t\t\t\t\t// optional closing #'s (not counted)\n\t\t\t\\n+\n\t\t/gm, function() {...});\n\t*/\n\n\ttext = text.replace(/^(\\#{1,6})[ \\t]*(.+?)[ \\t]*\\#*\\n+/gm,\n\t\tfunction(wholeMatch,m1,m2) {\n\t\t\tvar h_level = m1.length;\n\t\t\treturn hashBlock(\"<h\" + h_level + \">\" + _RunSpanGamut(m2) + \"</h\" + h_level + \">\");\n\t\t});\n\n\treturn text;\n}\n\n// This declaration keeps Dojo compressor from outputting garbage:\nvar _ProcessListItems;\n\nvar _DoLists = function(text) {\n//\n// Form HTML ordered (numbered) and unordered (bulleted) lists.\n//\n\n\t// attacklab: add sentinel to hack around khtml/safari bug:\n\t// /web/20140209091220/http://bugs.webkit.org/show_bug.cgi?id=11231\n\ttext += \"~0\";\n\n\t// Re-usable pattern to match any entirel ul or ol list:\n\n\t/*\n\t\tvar whole_list = /\n\t\t(\t\t\t\t\t\t\t\t\t// $1 = whole list\n\t\t\t(\t\t\t\t\t\t\t\t// $2\n\t\t\t\t[ ]{0,3}\t\t\t\t\t// attacklab: g_tab_width - 1\n\t\t\t\t([*+-]|\\d+[.])\t\t\t\t// $3 = first list item marker\n\t\t\t\t[ \\t]+\n\t\t\t)\n\t\t\t[^\\r]+?\n\t\t\t(\t\t\t\t\t\t\t\t// $4\n\t\t\t\t~0\t\t\t\t\t\t\t// sentinel for workaround; should be $\n\t\t\t|\n\t\t\t\t\\n{2,}\n\t\t\t\t(?=\\S)\n\t\t\t\t(?!\t\t\t\t\t\t\t// Negative lookahead for another list item marker\n\t\t\t\t\t[ \\t]*\n\t\t\t\t\t(?:[*+-]|\\d+[.])[ \\t]+\n\t\t\t\t)\n\t\t\t)\n\t\t)/g\n\t*/\n\tvar whole_list = /^(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm;\n\n\tif (g_list_level) {\n\t\ttext = text.replace(whole_list,function(wholeMatch,m1,m2) {\n\t\t\tvar list = m1;\n\t\t\tvar list_type = (m2.search(/[*+-]/g)>-1) ? \"ul\" : \"ol\";\n\n\t\t\t// Turn double returns into triple returns, so that we can make a\n\t\t\t// paragraph for the last item in a list, if necessary:\n\t\t\tlist = list.replace(/\\n{2,}/g,\"\\n\\n\\n\");;\n\t\t\tvar result = _ProcessListItems(list);\n\t\n\t\t\t// Trim any trailing whitespace, to put the closing `</$list_type>`\n\t\t\t// up on the preceding line, to get it past the current stupid\n\t\t\t// HTML block parser. This is a hack to work around the terrible\n\t\t\t// hack that is the HTML block parser.\n\t\t\tresult = result.replace(/\\s+$/,\"\");\n\t\t\tresult = \"<\"+list_type+\">\" + result + \"</\"+list_type+\">\\n\";\n\t\t\treturn result;\n\t\t});\n\t} else {\n\t\twhole_list = /(\\n\\n|^\\n?)(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/g;\n\t\ttext = text.replace(whole_list,function(wholeMatch,m1,m2,m3) {\n\t\t\tvar runup = m1;\n\t\t\tvar list = m2;\n\n\t\t\tvar list_type = (m3.search(/[*+-]/g)>-1) ? \"ul\" : \"ol\";\n\t\t\t// Turn double returns into triple returns, so that we can make a\n\t\t\t// paragraph for the last item in a list, if necessary:\n\t\t\tvar list = list.replace(/\\n{2,}/g,\"\\n\\n\\n\");;\n\t\t\tvar result = _ProcessListItems(list);\n\t\t\tresult = runup + \"<\"+list_type+\">\\n\" + result + \"</\"+list_type+\">\\n\";\t\n\t\t\treturn result;\n\t\t});\n\t}\n\n\t// attacklab: strip sentinel\n\ttext = text.replace(/~0/,\"\");\n\n\treturn text;\n}\n\n_ProcessListItems = function(list_str) {\n//\n//  Process the contents of a single ordered or unordered list, splitting it\n//  into individual list items.\n//\n\t// The $g_list_level global keeps track of when we're inside a list.\n\t// Each time we enter a list, we increment it; when we leave a list,\n\t// we decrement. If it's zero, we're not in a list anymore.\n\t//\n\t// We do this because when we're not inside a list, we want to treat\n\t// something like this:\n\t//\n\t//    I recommend upgrading to version\n\t//    8. Oops, now this line is treated\n\t//    as a sub-list.\n\t//\n\t// As a single paragraph, despite the fact that the second line starts\n\t// with a digit-period-space sequence.\n\t//\n\t// Whereas when we're inside a list (or sub-list), that line will be\n\t// treated as the start of a sub-list. What a kludge, huh? This is\n\t// an aspect of Markdown's syntax that's hard to parse perfectly\n\t// without resorting to mind-reading. Perhaps the solution is to\n\t// change the syntax rules such that sub-lists must start with a\n\t// starting cardinal number; e.g. \"1.\" or \"a.\".\n\n\tg_list_level++;\n\n\t// trim trailing blank lines:\n\tlist_str = list_str.replace(/\\n{2,}$/,\"\\n\");\n\n\t// attacklab: add sentinel to emulate \\z\n\tlist_str += \"~0\";\n\n\t/*\n\t\tlist_str = list_str.replace(/\n\t\t\t(\\n)?\t\t\t\t\t\t\t// leading line = $1\n\t\t\t(^[ \\t]*)\t\t\t\t\t\t// leading whitespace = $2\n\t\t\t([*+-]|\\d+[.]) [ \\t]+\t\t\t// list marker = $3\n\t\t\t([^\\r]+?\t\t\t\t\t\t// list item text   = $4\n\t\t\t(\\n{1,2}))\n\t\t\t(?= \\n* (~0 | \\2 ([*+-]|\\d+[.]) [ \\t]+))\n\t\t/gm, function(){...});\n\t*/\n\tlist_str = list_str.replace(/(\\n)?(^[ \\t]*)([*+-]|\\d+[.])[ \\t]+([^\\r]+?(\\n{1,2}))(?=\\n*(~0|\\2([*+-]|\\d+[.])[ \\t]+))/gm,\n\t\tfunction(wholeMatch,m1,m2,m3,m4){\n\t\t\tvar item = m4;\n\t\t\tvar leading_line = m1;\n\t\t\tvar leading_space = m2;\n\n\t\t\tif (leading_line || (item.search(/\\n{2,}/)>-1)) {\n\t\t\t\titem = _RunBlockGamut(_Outdent(item));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Recursion for sub-lists:\n\t\t\t\titem = _DoLists(_Outdent(item));\n\t\t\t\titem = item.replace(/\\n$/,\"\"); // chomp(item)\n\t\t\t\titem = _RunSpanGamut(item);\n\t\t\t}\n\n\t\t\treturn  \"<li>\" + item + \"</li>\\n\";\n\t\t}\n\t);\n\n\t// attacklab: strip sentinel\n\tlist_str = list_str.replace(/~0/g,\"\");\n\n\tg_list_level--;\n\treturn list_str;\n}\n\n\nvar _DoCodeBlocks = function(text) {\n//\n//  Process Markdown `<pre><code>` blocks.\n//  \n\n\t/*\n\t\ttext = text.replace(text,\n\t\t\t/(?:\\n\\n|^)\n\t\t\t(\t\t\t\t\t\t\t\t// $1 = the code block -- one or more lines, starting with a space/tab\n\t\t\t\t(?:\n\t\t\t\t\t(?:[ ]{4}|\\t)\t\t\t// Lines must start with a tab or a tab-width of spaces - attacklab: g_tab_width\n\t\t\t\t\t.*\\n+\n\t\t\t\t)+\n\t\t\t)\n\t\t\t(\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))\t// attacklab: g_tab_width\n\t\t/g,function(){...});\n\t*/\n\n\t// attacklab: sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\n\ttext += \"~0\";\n\t\n\ttext = text.replace(/(?:\\n\\n|^)((?:(?:[ ]{4}|\\t).*\\n+)+)(\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))/g,\n\t\tfunction(wholeMatch,m1,m2) {\n\t\t\tvar codeblock = m1;\n\t\t\tvar nextChar = m2;\n\t\t\n\t\t\tcodeblock = _EncodeCode( _Outdent(codeblock));\n\t\t\tcodeblock = _Detab(codeblock);\n\t\t\tcodeblock = codeblock.replace(/^\\n+/g,\"\"); // trim leading newlines\n\t\t\tcodeblock = codeblock.replace(/\\n+$/g,\"\"); // trim trailing whitespace\n\n\t\t\tcodeblock = \"<pre><code>\" + codeblock + \"\\n</code></pre>\";\n\n\t\t\treturn hashBlock(codeblock) + nextChar;\n\t\t}\n\t);\n\n\t// attacklab: strip sentinel\n\ttext = text.replace(/~0/,\"\");\n\n\treturn text;\n}\n\nvar hashBlock = function(text) {\n\ttext = text.replace(/(^\\n+|\\n+$)/g,\"\");\n\treturn \"\\n\\n~K\" + (g_html_blocks.push(text)-1) + \"K\\n\\n\";\n}\n\n\nvar _DoCodeSpans = function(text) {\n//\n//   *  Backtick quotes are used for <code></code> spans.\n// \n//   *  You can use multiple backticks as the delimiters if you want to\n//\t include literal backticks in the code span. So, this input:\n//\t \n//\t\t Just type ``foo `bar` baz`` at the prompt.\n//\t \n//\t   Will translate to:\n//\t \n//\t\t <p>Just type <code>foo `bar` baz</code> at the prompt.</p>\n//\t \n//\tThere's no arbitrary limit to the number of backticks you\n//\tcan use as delimters. If you need three consecutive backticks\n//\tin your code, use four for delimiters, etc.\n//\n//  *  You can use spaces to get literal backticks at the edges:\n//\t \n//\t\t ... type `` `bar` `` ...\n//\t \n//\t   Turns to:\n//\t \n//\t\t ... type <code>`bar`</code> ...\n//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t\t(^|[^\\\\])\t\t\t\t\t// Character before opening ` can't be a backslash\n\t\t\t(`+)\t\t\t\t\t\t// $2 = Opening run of `\n\t\t\t(\t\t\t\t\t\t\t// $3 = The code block\n\t\t\t\t[^\\r]*?\n\t\t\t\t[^`]\t\t\t\t\t// attacklab: work around lack of lookbehind\n\t\t\t)\n\t\t\t\\2\t\t\t\t\t\t\t// Matching closer\n\t\t\t(?!`)\n\t\t/gm, function(){...});\n\t*/\n\n\ttext = text.replace(/(^|[^\\\\])(`+)([^\\r]*?[^`])\\2(?!`)/gm,\n\t\tfunction(wholeMatch,m1,m2,m3,m4) {\n\t\t\tvar c = m3;\n\t\t\tc = c.replace(/^([ \\t]*)/g,\"\");\t// leading whitespace\n\t\t\tc = c.replace(/[ \\t]*$/g,\"\");\t// trailing whitespace\n\t\t\tc = _EncodeCode(c);\n\t\t\treturn m1+\"<code>\"+c+\"</code>\";\n\t\t});\n\n\treturn text;\n}\n\n\nvar _EncodeCode = function(text) {\n//\n// Encode/escape certain characters inside Markdown code runs.\n// The point is that in code, these characters are literals,\n// and lose their special Markdown meanings.\n//\n\t// Encode all ampersands; HTML entities are not\n\t// entities within a Markdown code span.\n\ttext = text.replace(/&/g,\"&amp;\");\n\n\t// Do the angle bracket song and dance:\n\ttext = text.replace(/</g,\"&lt;\");\n\ttext = text.replace(/>/g,\"&gt;\");\n\n\t// Now, escape characters that are magic in Markdown:\n\ttext = escapeCharacters(text,\"\\*_{}[]\\\\\",false);\n\n// jj the line above breaks this:\n//---\n\n//* Item\n\n//   1. Subitem\n\n//            special char: *\n//---\n\n\treturn text;\n}\n\n\nvar _DoItalicsAndBold = function(text) {\n\n\t// <strong> must go first:\n\ttext = text.replace(/(\\*\\*|__)(?=\\S)([^\\r]*?\\S[*_]*)\\1/g,\n\t\t\"<strong>$2</strong>\");\n\n\ttext = text.replace(/(\\*|_)(?=\\S)([^\\r]*?\\S)\\1/g,\n\t\t\"<em>$2</em>\");\n\n\treturn text;\n}\n\n\nvar _DoBlockQuotes = function(text) {\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t\t\t// Wrap whole match in $1\n\t\t\t(\n\t\t\t\t^[ \\t]*>[ \\t]?\t\t\t// '>' at the start of a line\n\t\t\t\t.+\\n\t\t\t\t\t// rest of the first line\n\t\t\t\t(.+\\n)*\t\t\t\t\t// subsequent consecutive lines\n\t\t\t\t\\n*\t\t\t\t\t\t// blanks\n\t\t\t)+\n\t\t)\n\t\t/gm, function(){...});\n\t*/\n\n\ttext = text.replace(/((^[ \\t]*>[ \\t]?.+\\n(.+\\n)*\\n*)+)/gm,\n\t\tfunction(wholeMatch,m1) {\n\t\t\tvar bq = m1;\n\n\t\t\t// attacklab: hack around Konqueror 3.5.4 bug:\n\t\t\t// \"----------bug\".replace(/^-/g,\"\") == \"bug\"\n\n\t\t\tbq = bq.replace(/^[ \\t]*>[ \\t]?/gm,\"~0\");\t// trim one level of quoting\n\n\t\t\t// attacklab: clean up hack\n\t\t\tbq = bq.replace(/~0/g,\"\");\n\n\t\t\tbq = bq.replace(/^[ \\t]+$/gm,\"\");\t\t// trim whitespace-only lines\n\t\t\tbq = _RunBlockGamut(bq);\t\t\t\t// recurse\n\t\t\t\n\t\t\tbq = bq.replace(/(^|\\n)/g,\"$1  \");\n\t\t\t// These leading spaces screw with <pre> content, so we need to fix that:\n\t\t\tbq = bq.replace(\n\t\t\t\t\t/(\\s*<pre>[^\\r]+?<\\/pre>)/gm,\n\t\t\t\tfunction(wholeMatch,m1) {\n\t\t\t\t\tvar pre = m1;\n\t\t\t\t\t// attacklab: hack around Konqueror 3.5.4 bug:\n\t\t\t\t\tpre = pre.replace(/^  /mg,\"~0\");\n\t\t\t\t\tpre = pre.replace(/~0/g,\"\");\n\t\t\t\t\treturn pre;\n\t\t\t\t});\n\t\t\t\n\t\t\treturn hashBlock(\"<blockquote>\\n\" + bq + \"\\n</blockquote>\");\n\t\t});\n\treturn text;\n}\n\n\nvar _FormParagraphs = function(text) {\n//\n//  Params:\n//    $text - string to process with html <p> tags\n//\n\n\t// Strip leading and trailing lines:\n\ttext = text.replace(/^\\n+/g,\"\");\n\ttext = text.replace(/\\n+$/g,\"\");\n\n\tvar grafs = text.split(/\\n{2,}/g);\n\tvar grafsOut = new Array();\n\n\t//\n\t// Wrap <p> tags.\n\t//\n\tvar end = grafs.length;\n\tfor (var i=0; i<end; i++) {\n\t\tvar str = grafs[i];\n\n\t\t// if this is an HTML marker, copy it\n\t\tif (str.search(/~K(\\d+)K/g) >= 0) {\n\t\t\tgrafsOut.push(str);\n\t\t}\n\t\telse if (str.search(/\\S/) >= 0) {\n\t\t\tstr = _RunSpanGamut(str);\n\t\t\tstr = str.replace(/^([ \\t]*)/g,\"<p>\");\n\t\t\tstr += \"</p>\"\n\t\t\tgrafsOut.push(str);\n\t\t}\n\n\t}\n\n\t//\n\t// Unhashify HTML blocks\n\t//\n\tend = grafsOut.length;\n\tfor (var i=0; i<end; i++) {\n\t\t// if this is a marker for an html block...\n\t\twhile (grafsOut[i].search(/~K(\\d+)K/) >= 0) {\n\t\t\tvar blockText = g_html_blocks[RegExp.$1];\n\t\t\tblockText = blockText.replace(/\\$/g,\"$$$$\"); // Escape any dollar signs\n\t\t\tgrafsOut[i] = grafsOut[i].replace(/~K\\d+K/,blockText);\n\t\t}\n\t}\n\n\treturn grafsOut.join(\"\\n\\n\");\n}\n\n\nvar _EncodeAmpsAndAngles = function(text) {\n// Smart processing for ampersands and angle brackets that need to be encoded.\n\t\n\t// Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:\n\t//   /web/20140209091220/http://bumppo.net/projects/amputator/\n\ttext = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\\w+);)/g,\"&amp;\");\n\t\n\t// Encode naked <'s\n\ttext = text.replace(/<(?![a-z\\/?\\$!])/gi,\"&lt;\");\n\t\n\treturn text;\n}\n\n\nvar _EncodeBackslashEscapes = function(text) {\n//\n//   Parameter:  String.\n//   Returns:\tThe string, with after processing the following backslash\n//\t\t\t   escape sequences.\n//\n\n\t// attacklab: The polite way to do this is with the new\n\t// escapeCharacters() function:\n\t//\n\t// \ttext = escapeCharacters(text,\"\\\\\",true);\n\t// \ttext = escapeCharacters(text,\"`*_{}[]()>#+-.!\",true);\n\t//\n\t// ...but we're sidestepping its use of the (slow) RegExp constructor\n\t// as an optimization for Firefox.  This function gets called a LOT.\n\n\ttext = text.replace(/\\\\(\\\\)/g,escapeCharacters_callback);\n\ttext = text.replace(/\\\\([`*_{}\\[\\]()>#+-.!])/g,escapeCharacters_callback);\n\treturn text;\n}\n\n\nvar _DoAutoLinks = function(text) {\n\n\ttext = text.replace(/<((https?|ftp|dict):[^'\">\\s]+)>/gi,\"<a href=\\\"$1\\\">$1</a>\");\n\n\t// Email addresses: <address@domain.foo>\n\n\t/*\n\t\ttext = text.replace(/\n\t\t\t<\n\t\t\t(?:mailto:)?\n\t\t\t(\n\t\t\t\t[-.\\w]+\n\t\t\t\t\\@\n\t\t\t\t[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+\n\t\t\t)\n\t\t\t>\n\t\t/gi, _DoAutoLinks_callback());\n\t*/\n\ttext = text.replace(/<(?:mailto:)?([-.\\w]+\\@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)>/gi,\n\t\tfunction(wholeMatch,m1) {\n\t\t\treturn _EncodeEmailAddress( _UnescapeSpecialChars(m1) );\n\t\t}\n\t);\n\n\treturn text;\n}\n\n\nvar _EncodeEmailAddress = function(addr) {\n//\n//  Input: an email address, e.g. \"foo@example.com\"\n//\n//  Output: the email address as a mailto link, with each character\n//\tof the address encoded as either a decimal or hex entity, in\n//\tthe hopes of foiling most address harvesting spam bots. E.g.:\n//\n//\t<a href=\"&#x6D;&#97;&#105;&#108;&#x74;&#111;:&#102;&#111;&#111;&#64;&#101;\n//\t   x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;\">&#102;&#111;&#111;\n//\t   &#64;&#101;x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;</a>\n//\n//  Based on a filter by Matthew Wickline, posted to the BBEdit-Talk\n//  mailing list: </web/20140209091220/http://tinyurl.com/yu7ue>\n//\n\n\t// attacklab: why can't javascript speak hex?\n\tfunction char2hex(ch) {\n\t\tvar hexDigits = '0123456789ABCDEF';\n\t\tvar dec = ch.charCodeAt(0);\n\t\treturn(hexDigits.charAt(dec>>4) + hexDigits.charAt(dec&15));\n\t}\n\n\tvar encode = [\n\t\tfunction(ch){return \"&#\"+ch.charCodeAt(0)+\";\";},\n\t\tfunction(ch){return \"&#x\"+char2hex(ch)+\";\";},\n\t\tfunction(ch){return ch;}\n\t];\n\n\taddr = \"mailto:\" + addr;\n\n\taddr = addr.replace(/./g, function(ch) {\n\t\tif (ch == \"@\") {\n\t\t   \t// this *must* be encoded. I insist.\n\t\t\tch = encode[Math.floor(Math.random()*2)](ch);\n\t\t} else if (ch !=\":\") {\n\t\t\t// leave ':' alone (to spot mailto: later)\n\t\t\tvar r = Math.random();\n\t\t\t// roughly 10% raw, 45% hex, 45% dec\n\t\t\tch =  (\n\t\t\t\t\tr > .9  ?\tencode[2](ch)   :\n\t\t\t\t\tr > .45 ?\tencode[1](ch)   :\n\t\t\t\t\t\t\t\tencode[0](ch)\n\t\t\t\t);\n\t\t}\n\t\treturn ch;\n\t});\n\n\taddr = \"<a href=\\\"\" + addr + \"\\\">\" + addr + \"</a>\";\n\taddr = addr.replace(/\">.+:/g,\"\\\">\"); // strip the mailto: from the visible part\n\n\treturn addr;\n}\n\n\nvar _UnescapeSpecialChars = function(text) {\n//\n// Swap back in all the special characters we've hidden.\n//\n\ttext = text.replace(/~E(\\d+)E/g,\n\t\tfunction(wholeMatch,m1) {\n\t\t\tvar charCodeToReplace = parseInt(m1);\n\t\t\treturn String.fromCharCode(charCodeToReplace);\n\t\t}\n\t);\n\treturn text;\n}\n\n\nvar _Outdent = function(text) {\n//\n// Remove one level of line-leading tabs or spaces\n//\n\n\t// attacklab: hack around Konqueror 3.5.4 bug:\n\t// \"----------bug\".replace(/^-/g,\"\") == \"bug\"\n\n\ttext = text.replace(/^(\\t|[ ]{1,4})/gm,\"~0\"); // attacklab: g_tab_width\n\n\t// attacklab: clean up hack\n\ttext = text.replace(/~0/g,\"\")\n\n\treturn text;\n}\n\nvar _Detab = function(text) {\n// attacklab: Detab's completely rewritten for speed.\n// In perl we could fix it by anchoring the regexp with \\G.\n// In javascript we're less fortunate.\n\n\t// expand first n-1 tabs\n\ttext = text.replace(/\\t(?=\\t)/g,\"    \"); // attacklab: g_tab_width\n\n\t// replace the nth with two sentinels\n\ttext = text.replace(/\\t/g,\"~A~B\");\n\n\t// use the sentinel to anchor our regex so it doesn't explode\n\ttext = text.replace(/~B(.+?)~A/g,\n\t\tfunction(wholeMatch,m1,m2) {\n\t\t\tvar leadingText = m1;\n\t\t\tvar numSpaces = 4 - leadingText.length % 4;  // attacklab: g_tab_width\n\n\t\t\t// there *must* be a better way to do this:\n\t\t\tfor (var i=0; i<numSpaces; i++) leadingText+=\" \";\n\n\t\t\treturn leadingText;\n\t\t}\n\t);\n\n\t// clean up sentinels\n\ttext = text.replace(/~A/g,\"    \");  // attacklab: g_tab_width\n\ttext = text.replace(/~B/g,\"\");\n\n\treturn text;\n}\n\n\n//\n//  attacklab: Utility functions\n//\n\n\nvar escapeCharacters = function(text, charsToEscape, afterBackslash) {\n\t// First we have to escape the escape characters so that\n\t// we can build a character class out of them\n\tvar regexString = \"([\" + charsToEscape.replace(/([\\[\\]\\\\])/g,\"\\\\$1\") + \"])\";\n\n\tif (afterBackslash) {\n\t\tregexString = \"\\\\\\\\\" + regexString;\n\t}\n\n\tvar regex = new RegExp(regexString,\"g\");\n\ttext = text.replace(regex,escapeCharacters_callback);\n\n\treturn text;\n}\n\n\nvar escapeCharacters_callback = function(wholeMatch,m1) {\n\tvar charCodeToEscape = m1.charCodeAt(0);\n\treturn \"~E\"+charCodeToEscape+\"E\";\n}\n\nexports.encode = exports.markdown = function (src) {\n   return exports.makeHtml(src);\n};\n\nexports.main = function (system) {\n    var command = system.args.shift();\n    if (!system.args.length) {\n        system.stdout.write(exports.markdown(system.stdin.read())).flush();\n    } else {\n        var arg;\n        while (arg = system.args.shift()) {\n            var out = system.fs.basename(arg, '.md') + '.html';\n            print(out);\n            system.fs.write(out, exports.markdown(system.fs.read(arg)));\n        }\n    }\n};","mustache":"/*\n * CommonJS-compatible mustache.js module\n *\n * See /web/20140209091220/http://github.com/janl/mustache.js for more info.\n */\n\n/*\n  mustache.js — Logic-less templates in JavaScript\n\n  See /web/20140209091220/http://mustache.github.com/ for more info.\n*/\n\nvar Mustache = function() {\n  var Renderer = function() {};\n\n  Renderer.prototype = {\n    otag: \"{{\",\n    ctag: \"}}\",\n    pragmas: {},\n    buffer: [],\n    pragmas_implemented: {\n      \"IMPLICIT-ITERATOR\": true\n    },\n    context: {},\n\n    render: function(template, context, partials, in_recursion) {\n      // reset buffer & set context\n      if(!in_recursion) {\n        this.context = context;\n        this.buffer = []; // TODO: make this non-lazy\n      }\n\n      // fail fast\n      if(!this.includes(\"\", template)) {\n        if(in_recursion) {\n          return template;\n        } else {\n          this.send(template);\n          return;\n        }\n      }\n\n      template = this.render_pragmas(template);\n      var html = this.render_section(template, context, partials);\n      if(in_recursion) {\n        return this.render_tags(html, context, partials, in_recursion);\n      }\n\n      this.render_tags(html, context, partials, in_recursion);\n    },\n\n    /*\n      Sends parsed lines\n    */\n    send: function(line) {\n      if(line != \"\") {\n        this.buffer.push(line);\n      }\n    },\n\n    /*\n      Looks for %PRAGMAS\n    */\n    render_pragmas: function(template) {\n      // no pragmas\n      if(!this.includes(\"%\", template)) {\n        return template;\n      }\n\n      var that = this;\n      var regex = new RegExp(this.otag + \"%([\\\\w-]+) ?([\\\\w]+=[\\\\w]+)?\" +\n            this.ctag);\n      return template.replace(regex, function(match, pragma, options) {\n        if(!that.pragmas_implemented[pragma]) {\n          throw({message: \n            \"This implementation of mustache doesn't understand the '\" +\n            pragma + \"' pragma\"});\n        }\n        that.pragmas[pragma] = {};\n        if(options) {\n          var opts = options.split(\"=\");\n          that.pragmas[pragma][opts[0]] = opts[1];\n        }\n        return \"\";\n        // ignore unknown pragmas silently\n      });\n    },\n\n    /*\n      Tries to find a partial in the curent scope and render it\n    */\n    render_partial: function(name, context, partials) {\n      name = this.trim(name);\n      if(!partials || partials[name] === undefined) {\n        throw({message: \"unknown_partial '\" + name + \"'\"});\n      }\n      if(typeof(context[name]) != \"object\") {\n        return this.render(partials[name], context, partials, true);\n      }\n      return this.render(partials[name], context[name], partials, true);\n    },\n\n    /*\n      Renders inverted (^) and normal (#) sections\n    */\n    render_section: function(template, context, partials) {\n      if(!this.includes(\"#\", template) && !this.includes(\"^\", template)) {\n        return template;\n      }\n\n      var that = this;\n      // CSW - Added \"+?\" so it finds the tighest bound, not the widest\n      var regex = new RegExp(this.otag + \"(\\\\^|\\\\#)\\\\s*(.+)\\\\s*\" + this.ctag +\n              \"\\n*([\\\\s\\\\S]+?)\" + this.otag + \"\\\\/\\\\s*\\\\2\\\\s*\" + this.ctag +\n              \"\\\\s*\", \"mg\");\n\n      // for each {{#foo}}{{/foo}} section do...\n      return template.replace(regex, function(match, type, name, content) {\n        var value = that.find(name, context);\n        if(type == \"^\") { // inverted section\n          if(!value || that.is_array(value) && value.length === 0) {\n            // false or empty list, render it\n            return that.render(content, context, partials, true);\n          } else {\n            return \"\";\n          }\n        } else if(type == \"#\") { // normal section\n          if(that.is_array(value)) { // Enumerable, Let's loop!\n            return that.map(value, function(row) {\n              return that.render(content, that.create_context(row),\n                partials, true);\n            }).join(\"\");\n          } else if(that.is_object(value)) { // Object, Use it as subcontext!\n            return that.render(content, that.create_context(value),\n              partials, true);\n          } else if(typeof value === \"function\") {\n            // higher order section\n            return value.call(context, content, function(text) {\n              return that.render(text, context, partials, true);\n            });\n          } else if(value) { // boolean section\n            return that.render(content, context, partials, true);\n          } else {\n            return \"\";\n          }\n        }\n      });\n    },\n\n    /*\n      Replace {{foo}} and friends with values from our view\n    */\n    render_tags: function(template, context, partials, in_recursion) {\n      // tit for tat\n      var that = this;\n\n      var new_regex = function() {\n        return new RegExp(that.otag + \"(=|!|>|\\\\{|%)?([^\\\\/#\\\\^]+?)\\\\1?\" +\n          that.ctag + \"+\", \"g\");\n      };\n\n      var regex = new_regex();\n      var tag_replace_callback = function(match, operator, name) {\n        switch(operator) {\n        case \"!\": // ignore comments\n          return \"\";\n        case \"=\": // set new delimiters, rebuild the replace regexp\n          that.set_delimiters(name);\n          regex = new_regex();\n          return \"\";\n        case \">\": // render partial\n          return that.render_partial(name, context, partials);\n        case \"{\": // the triple mustache is unescaped\n          return that.find(name, context);\n        default: // escape the value\n          return that.escape(that.find(name, context));\n        }\n      };\n      var lines = template.split(\"\\n\");\n      for(var i = 0; i < lines.length; i++) {\n        lines[i] = lines[i].replace(regex, tag_replace_callback, this);\n        if(!in_recursion) {\n          this.send(lines[i]);\n        }\n      }\n\n      if(in_recursion) {\n        return lines.join(\"\\n\");\n      }\n    },\n\n    set_delimiters: function(delimiters) {\n      var dels = delimiters.split(\" \");\n      this.otag = this.escape_regex(dels[0]);\n      this.ctag = this.escape_regex(dels[1]);\n    },\n\n    escape_regex: function(text) {\n      // thank you Simon Willison\n      if(!arguments.callee.sRE) {\n        var specials = [\n          '/', '.', '*', '+', '?', '|',\n          '(', ')', '[', ']', '{', '}', '\\\\'\n        ];\n        arguments.callee.sRE = new RegExp(\n          '(\\\\' + specials.join('|\\\\') + ')', 'g'\n        );\n      }\n      return text.replace(arguments.callee.sRE, '\\\\$1');\n    },\n\n    /*\n      find `name` in current `context`. That is find me a value\n      from the view object\n    */\n    find: function(name, context) {\n      name = this.trim(name);\n\n      // Checks whether a value is thruthy or false or 0\n      function is_kinda_truthy(bool) {\n        return bool === false || bool === 0 || bool;\n      }\n\n      var value;\n      if(is_kinda_truthy(context[name])) {\n        value = context[name];\n      } else if(is_kinda_truthy(this.context[name])) {\n        value = this.context[name];\n      }\n\n      if(typeof value === \"function\") {\n        return value.apply(context);\n      }\n      if(value !== undefined) {\n        return value;\n      }\n      // silently ignore unkown variables\n      return \"\";\n    },\n\n    // Utility methods\n\n    /* includes tag */\n    includes: function(needle, haystack) {\n      return haystack.indexOf(this.otag + needle) != -1;\n    },\n\n    /*\n      Does away with nasty characters\n    */\n    escape: function(s) {\n      s = String(s === null ? \"\" : s);\n      return s.replace(/&(?!\\w+;)|[\"<>\\\\]/g, function(s) {\n        switch(s) {\n        case \"&\": return \"&amp;\";\n        case \"\\\\\": return \"\\\\\\\\\";\n        case '\"': return '\\\"';\n        case \"<\": return \"&lt;\";\n        case \">\": return \"&gt;\";\n        default: return s;\n        }\n      });\n    },\n\n    // by @langalex, support for arrays of strings\n    create_context: function(_context) {\n      if(this.is_object(_context)) {\n        return _context;\n      } else {\n        var iterator = \".\";\n        if(this.pragmas[\"IMPLICIT-ITERATOR\"]) {\n          iterator = this.pragmas[\"IMPLICIT-ITERATOR\"].iterator;\n        }\n        var ctx = {};\n        ctx[iterator] = _context;\n        return ctx;\n      }\n    },\n\n    is_object: function(a) {\n      return a && typeof a == \"object\";\n    },\n\n    is_array: function(a) {\n      return Object.prototype.toString.call(a) === '[object Array]';\n    },\n\n    /*\n      Gets rid of leading and trailing whitespace\n    */\n    trim: function(s) {\n      return s.replace(/^\\s*|\\s*$/g, \"\");\n    },\n\n    /*\n      Why, why, why? Because IE. Cry, cry cry.\n    */\n    map: function(array, fn) {\n      if (typeof array.map == \"function\") {\n        return array.map(fn);\n      } else {\n        var r = [];\n        var l = array.length;\n        for(var i = 0; i < l; i++) {\n          r.push(fn(array[i]));\n        }\n        return r;\n      }\n    }\n  };\n\n  return({\n    name: \"mustache.js\",\n    version: \"0.3.1-dev\",\n\n    /*\n      Turns a template and view into HTML\n    */\n    to_html: function(template, view, partials, send_fun) {\n      var renderer = new Renderer();\n      if(send_fun) {\n        renderer.send = send_fun;\n      }\n      renderer.render(template, view, partials);\n      if(!send_fun) {\n        return renderer.buffer.join(\"\\n\");\n      }\n    },\n    escape : function(text) {\n      return new Renderer().escape(text);\n    }\n  });\n}();\n\nexports.name = Mustache.name;\nexports.version = Mustache.version;\n\nexports.to_html = Mustache.to_html;\nexports.escape = Mustache.escape;","md5":"/*\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See /web/20140209091220/http://pajhome.org.uk/crypt/md5 for more info.\n */\n\n/*\n * Configurable variables. You may need to tweak these to be compatible with\n * the server-side, but the defaults work in most cases.\n */\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\nvar b64pad  = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\nvar chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */\n\n/*\n * These are the functions you'll usually want to call\n * They take string arguments and return either hex or base-64 encoded strings\n */\nfunction hex_md5(s){ return binl2hex(core_md5(str2binl(s), s.length * chrsz));}\nfunction b64_md5(s){ return binl2b64(core_md5(str2binl(s), s.length * chrsz));}\nfunction str_md5(s){ return binl2str(core_md5(str2binl(s), s.length * chrsz));}\nfunction hex_hmac_md5(key, data) { return binl2hex(core_hmac_md5(key, data)); }\nfunction b64_hmac_md5(key, data) { return binl2b64(core_hmac_md5(key, data)); }\nfunction str_hmac_md5(key, data) { return binl2str(core_hmac_md5(key, data)); }\n\n/*\n * Perform a simple self-test to see if the VM is working\n */\nfunction md5_vm_test()\n{\n  return hex_md5(\"abc\") == \"900150983cd24fb0d6963f7d28e17f72\";\n}\n\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length\n keep\n */\nfunction core_md5(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << ((len) % 32);\n  x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n\n    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\n    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\n    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\n    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\n    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\n    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\n    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\n    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\n    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\n    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\n    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\n    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\n    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\n    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\n    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\n    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\n\n    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\n    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\n    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\n    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\n    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\n    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\n    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\n    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\n    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\n    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\n    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\n    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\n    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\n    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\n    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\n    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\n\n    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\n    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\n    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\n    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\n    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\n    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\n    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\n    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\n    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\n    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\n    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\n    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\n    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\n    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\n    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\n    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\n\n    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\n    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\n    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\n    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\n    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\n    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\n    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\n    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\n    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\n    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\n    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\n    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\n    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\n    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\n    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\n    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n  }\n  return Array(a, b, c, d);\n\n}\n\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\nfunction md5_cmn(q, a, b, x, s, t)\n{\n  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);\n}\nfunction md5_ff(a, b, c, d, x, s, t)\n{\n  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\n}\nfunction md5_gg(a, b, c, d, x, s, t)\n{\n  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\n}\nfunction md5_hh(a, b, c, d, x, s, t)\n{\n  return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n}\nfunction md5_ii(a, b, c, d, x, s, t)\n{\n  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\n}\n\n/*\n * Calculate the HMAC-MD5, of a key and some data\n */\nfunction core_hmac_md5(key, data)\n{\n  var bkey = str2binl(key);\n  if(bkey.length > 16) bkey = core_md5(bkey, key.length * chrsz);\n\n  var ipad = Array(16), opad = Array(16);\n  for(var i = 0; i < 16; i++)\n  {\n    ipad[i] = bkey[i] ^ 0x36363636;\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\n  }\n\n  var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);\n  return core_md5(opad.concat(hash), 512 + 128);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction bit_rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/*\n * Convert a string to an array of little-endian words\n * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.\n keep\n */\nfunction str2binl(str)\n{\n  var bin = Array();\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < str.length * chrsz; i += chrsz)\n    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (i%32);\n  return bin;\n}\n\n/*\n * Convert an array of little-endian words to a string\n */\nfunction binl2str(bin)\n{\n  var str = \"\";\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < bin.length * 32; i += chrsz)\n    str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & mask);\n  return str;\n}\n\n/*\n * Convert an array of little-endian words to a hex string.\n keep\n */\nfunction binl2hex(binarray)\n{\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i++)\n  {\n    str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +\n           hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);\n  }\n  return str;\n}\n\n/*\n * Convert an array of little-endian words to a base-64 string\n */\nfunction binl2b64(binarray)\n{\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i += 3)\n  {\n    var triplet = (((binarray[i   >> 2] >> 8 * ( i   %4)) & 0xFF) << 16)\n                | (((binarray[i+1 >> 2] >> 8 * ((i+1)%4)) & 0xFF) << 8 )\n                |  ((binarray[i+2 >> 2] >> 8 * ((i+2)%4)) & 0xFF);\n    for(var j = 0; j < 4; j++)\n    {\n      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;\n      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);\n    }\n  }\n  return str;\n}\n\nexports.hex = hex_md5;"}}}};
    $.couch.app(function(app) {
      $("#account").evently("account", app);
      $("#profile").evently("profile", app);
      $.evently.connect("#account","#profile", ["loggedIn","loggedOut"]);
      $$("#wiki").docid = "backbone";
      $$("#wiki").title = "Using backbone.js with couchapp";
      $("#wiki").evently("wiki", app);
      $("#comments").evently("comments", app);
      $("#tools").evently("tools", app);
      $.pathbinder.begin("");
    }, opts);
  </script>
</html>




<!--
     FILE ARCHIVED ON 9:12:20 Feb 9, 2014 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 21:27:17 Oct 23, 2014.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
